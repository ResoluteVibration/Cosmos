<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Galaxy Animation</title>
    <style>
        /* Basic reset and full-screen canvas styling */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Style for the information text */
        .info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            text-align: center;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        /* Position the GUI panel */
        .lil-gui {
            top: 60px !important;
        }
    </style>
    <!-- Google Fonts for a nicer text style -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Canvas element for Three.js to render on -->
    <canvas id="galaxyCanvas"></canvas>
    
    <!-- Information text -->
    <div class="info">3D Galaxy Animation with Three.js & Anime.js</div>

    <!-- CDN for Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- CDN for OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- CDN for lil-gui -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>

    <!-- CDN for Anime.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <script>
        // === Basic Scene Setup ===
        const canvas = document.getElementById('galaxyCanvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 2;


        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // === Camera Controls ===
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Adds a smooth, inertial effect to the movement
        controls.minDistance = 2; // Prevent zooming in too close
        controls.maxDistance = 50; // Prevent zooming out too far

        // === Galaxy Generation ===
        let galaxyParticles = null;

        const parameters = {
            count: 200000,
            size: 0.01,
            radius: 5,
            branches: 4,
            spin: 1,
            randomness: 0.4,
            randomnessPower: 3,
            insideColor: '#ff6030',
            outsideColor: '#1b3984'
        };

        const generateGalaxy = () => {
            // If a galaxy already exists, remove it from the scene
            if (galaxyParticles !== null) {
                galaxyParticles.geometry.dispose();
                galaxyParticles.material.dispose();
                scene.remove(galaxyParticles);
            }

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(parameters.count * 3);
            const colors = new Float32Array(parameters.count * 3);

            const colorInside = new THREE.Color(parameters.insideColor);
            const colorOutside = new THREE.Color(parameters.outsideColor);

            for (let i = 0; i < parameters.count; i++) {
                // Position
                const i3 = i * 3;
                const radius = Math.random() * parameters.radius;
                const spinAngle = radius * parameters.spin;
                const branchAngle = ((i % parameters.branches) / parameters.branches) * Math.PI * 2;

                const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;

                positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                positions[i3 + 1] = randomY;
                positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                
                // Color
                const mixedColor = colorInside.clone();
                mixedColor.lerp(colorOutside, radius / parameters.radius);

                colors[i3] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Material
            const material = new THREE.PointsMaterial({
                size: parameters.size,
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });

            // Create the points object and add it to the scene
            galaxyParticles = new THREE.Points(geometry, material);
            scene.add(galaxyParticles);
        };

        generateGalaxy();
        
        // === GUI Controls ===
        const gui = new lil.GUI({ title: 'Galaxy Controls' });
        gui.add(parameters, 'count').min(100).max(500000).step(100).name('Star Count').onFinishChange(generateGalaxy);
        gui.add(parameters, 'size').min(0.001).max(0.1).step(0.001).name('Star Size').onFinishChange(generateGalaxy);
        gui.add(parameters, 'radius').min(0.1).max(20).step(0.1).name('Galaxy Radius').onFinishChange(generateGalaxy);
        gui.add(parameters, 'branches').min(2).max(20).step(1).name('Branches').onFinishChange(generateGalaxy);
        gui.add(parameters, 'spin').min(-5).max(5).step(0.001).name('Spin').onFinishChange(generateGalaxy);
        gui.add(parameters, 'randomness').min(0).max(2).step(0.001).name('Randomness').onFinishChange(generateGalaxy);
        gui.add(parameters, 'randomnessPower').min(1).max(10).step(0.001).name('Randomness Power').onFinishChange(generateGalaxy);
        gui.addColor(parameters, 'insideColor').name('Core Color').onFinishChange(generateGalaxy);
        gui.addColor(parameters, 'outsideColor').name('Outer Color').onFinishChange(generateGalaxy);

        // === Animation using Anime.js ===
        // We'll animate an object and apply its values to the galaxy in the render loop
        const animationState = { rotationY: 0 };
        
        anime({
            targets: animationState,
            rotationY: Math.PI * 2,
            duration: 40000, // 40 seconds for a full rotation
            easing: 'linear',
            loop: true
        });

        // === Render Loop ===
        const clock = new THREE.Clock();

        const animate = () => {
            const elapsedTime = clock.getElapsedTime();

            // Apply the rotation from anime.js
            if(galaxyParticles) {
                galaxyParticles.rotation.y = animationState.rotationY;
            }
            
            // Update controls for damping effect
            controls.update();

            // Render the scene
            renderer.render(scene, camera);

            // Call animate again on the next frame
            requestAnimationFrame(animate);
        };

        animate();

        // === Handle Window Resizing ===
        window.addEventListener('resize', () => {
            // Update camera
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // The old mouse interaction code is removed to allow OrbitControls to work.

    </script>
</body>
</html>



