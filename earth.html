<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smashable 3D Earth</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
    <script>
        window.onload = function () {
            // --- Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 2;

            // --- Geometries and Materials ---
            let earthGroup = new THREE.Group();
            let pieces = [];
            const numPieces = 10000;
            const pieceSize = 0.05;

            // Simple Earth model
            function createEarth() {
                const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
                const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x004d99, wireframe: true, transparent: true, opacity: 0.5 });
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earthGroup.add(earth);
            }
            
            // Create individual pieces for the effect
            function createPieces() {
                const pieceGeometry = new THREE.BoxGeometry(pieceSize, pieceSize, pieceSize);
                const pieceMaterial = new THREE.MeshBasicMaterial({ color: 0x0080ff });
                
                for (let i = 0; i < numPieces; i++) {
                    const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
                    // Position pieces on the surface of the earth
                    const position = new THREE.Vector3().setFromSphericalCoords(
                        1,
                        Math.random() * Math.PI,
                        Math.random() * 2 * Math.PI
                    );
                    piece.position.copy(position);
                    // Store the original position to regenerate later
                    piece.userData.originalPosition = position.clone();
                    piece.userData.isDispersed = false;
                    pieces.push(piece);
                    earthGroup.add(piece);
                }
            }
            
            // Add the name "ASHWIN" in 3D
            function createName() {
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const text = "ASHWIN";
                    const textGeometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: 0.2,
                        height: 0.05,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.01,
                        bevelSize: 0.01,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    textGeometry.center();
                    
                    const textMaterial = new THREE.MeshNormalMaterial();
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    earthGroup.add(textMesh);
                });
            }

            createEarth();
            createPieces();
            createName();
            scene.add(earthGroup);

            // --- Animation Loop ---
            const animate = function() {
                requestAnimationFrame(animate);
                
                // Rotation for the main Earth mesh
                earthGroup.rotation.y += 0.002;

                pieces.forEach(piece => {
                    if (!piece.userData.isDispersed) {
                        piece.rotation.y += 0.002;
                        piece.position.lerp(piece.userData.originalPosition, 0.1);
                    } else {
                        piece.position.add(piece.velocity);
                        piece.material.opacity -= 0.005;
                    }
                });

                renderer.render(scene, camera);
            };

            // --- Mouse Controls ---
            const mouse = new THREE.Vector2();
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                // Check if the user is dragging to rotate, otherwise, disperse the pieces
                if (isDragging) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    earthGroup.rotation.y += deltaX * 0.005;
                    earthGroup.rotation.x += deltaY * 0.005;
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                } else {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    // Raycaster to check for intersection with the earth
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    
                    pieces.forEach(piece => {
                        const distance = piece.position.distanceTo(raycaster.ray.origin);
                        if (distance < 1.5 && !piece.userData.isDispersed) {
                            piece.userData.isDispersed = true;
                            piece.velocity = piece.position.clone().normalize().multiplyScalar(Math.random() * 0.05);
                            piece.material.transparent = true;
                            piece.material.opacity = 1;
                        } else if (distance >= 1.5 && piece.userData.isDispersed) {
                            piece.userData.isDispersed = false;
                            piece.material.opacity = 1;
                        }
                    });
                }
            });

            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            });
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // --- Window Resize ---
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        };
    </script>
</body>
</html>
