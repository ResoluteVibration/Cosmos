<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expanded Solar System</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: grab;
        }
        body.grabbing {
            cursor: grabbing;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }
        #pov-menu, #stats-box {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 14px;
        }
        .planet-button, .facing-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            font-weight: bold;
        }
        .planet-button:hover, .facing-button:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }
        .planet-button.active {
            background: #00ffc8;
            color: black;
        }
        #facing-buttons {
            display: none;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        #minimap-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 250px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 99;
        }
        #info-box {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 101;
            display: none;
            max-width: 300px;
        }
        #info-box h1 {
            margin-top: 0;
            font-size: 1.5em;
            text-align: center;
            color: #00ffc8;
        }
        #info-box p {
            margin: 5px 0;
            font-size: 0.9em;
        }
        @media (max-width: 768px) {
            #ui-container {
                right: 10px;
                top: 10px;
            }
            #info-box, #minimap-container {
                left: 10px;
                bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="info-box">
        <h1>Planet Interior</h1>
        <p>Use your mouse or touch to look around.</p>
        <p>You are now inside the planet.</p>
    </div>
    <div id="ui-container">
        <div id="pov-menu"></div>
        <div id="stats-box">
            <p><strong>Camera Mode:</strong> <span id="camera-mode-text">Global</span></p>
            <p><strong>Focused Body:</strong> <span id="focused-body-text">None</span></p>
        </div>
    </div>
    <div id="minimap-container">
        <canvas id="minimap"></canvas>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script>
        window.onload = function () {
            // --- Global Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000000000000000000000000000000000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            renderer.setClearColor(0x000000, 1);

            // Define solar system's origin at the center
            const solarSystemOrigin = new THREE.Vector3(0, 0, 0);

            // Create a group for the solar system to be moved as a whole
            const solarSystemGroup = new THREE.Group();
            solarSystemGroup.position.copy(solarSystemOrigin);
            scene.add(solarSystemGroup);
            
            // Camera position and target
            camera.position.set(0, 10000, 20000);
            camera.lookAt(solarSystemOrigin);

            // --- Orbit Controls for free camera movement ---
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.copy(solarSystemOrigin);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 50;
            // Set maxDistance to be just beyond the farthest planet's orbit
            controls.maxDistance = 600000000000;
            controls.enabled = true;

            // Update mouse cursor based on controls state
            document.body.addEventListener('mousedown', () => {
                if (controls.enabled) document.body.classList.add('grabbing');
            });
            document.body.addEventListener('mouseup', () => {
                document.body.classList.remove('grabbing');
            });

            // --- Mini-map Scene Setup ---
            const minimapContainer = document.getElementById('minimap-container');
            const minimapCanvas = document.getElementById('minimap');
            const minimapScene = new THREE.Scene();
            const minimapCamera = new THREE.OrthographicCamera(-80000, 80000, 80000, -80000, 1, 1000000);
            minimapCamera.position.set(0, 200, 0);
            minimapCamera.lookAt(0, 0, 0);
            const minimapRenderer = new THREE.WebGLRenderer({ canvas: minimapCanvas, antialias: true, alpha: true });
            minimapRenderer.setSize(minimapContainer.offsetWidth, minimapContainer.offsetHeight);

            // --- Create Sun and Planets with relative cosmic distances ---
            const sunGeometry = new THREE.IcosahedronGeometry(20, 5);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, transparent: true, opacity: 0.2 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            solarSystemGroup.add(sun);
            sun.name = 'Sun';
            sun.userData.initialScale = new THREE.Vector3(1, 1, 1);

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                const createLabel = (text) => {
                    const textGeometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: 8,
                        height: 2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.5,
                        bevelSize: 0.5,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    textGeometry.computeBoundingBox();
                    const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 1
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    return textMesh;
                };

                const sunLabel = createLabel('SUN');
                sunLabel.position.y = 30;
                sun.add(sunLabel);

                planets.forEach(p => {
                    const planetLabel = createLabel(p.mesh.name.toUpperCase());
                    planetLabel.position.y = p.mesh.userData.radius * 2;
                    p.mesh.add(planetLabel);
                });
                
                blackHoles.forEach(bh => {
                    const bhLabel = createLabel(bh.core.name.toUpperCase());
                    bhLabel.position.y = bh.core.userData.radius * 2;
                    bh.core.add(bhLabel);
                });
            });

            const pointLight = new THREE.PointLight(0xffffff, 2, 0, 0);
            pointLight.position.set(0, 0, 0);
            solarSystemGroup.add(pointLight);

            // Adjusted distances to be more spread out
            const planetsData = [
                { name: 'Mercury', size: 1, color: 0x888888, distance: 3500, orbitSpeed: 0.0083, rotationSpeed: 0.04 },
                { name: 'Venus', size: 2, color: 0xcc6600, distance: 6000, orbitSpeed: 0.0032, rotationSpeed: 0.02 },
                { name: 'Earth', size: 2.2, color: 0x0066ff, distance: 9000, orbitSpeed: 0.002, rotationSpeed: 0.03 },
                { name: 'Mars', size: 1.5, color: 0xff3300, distance: 12000, orbitSpeed: 0.00106, rotationSpeed: 0.025 },
                { name: 'Jupiter', size: 10, color: 0xcc9966, distance: 20000, orbitSpeed: 0.00016, rotationSpeed: 0.05 },
                { name: 'Saturn', size: 8, color: 0xccaa77, distance: 30000, orbitSpeed: 0.000067, rotationSpeed: 0.04, hasRings: true },
                { name: 'Uranus', size: 7, color: 0x99ffff, distance: 40000, orbitSpeed: 0.000023, rotationSpeed: 0.035, hasRings: true },
                { name: 'Neptune', size: 6.5, color: 0x0033ff, distance: 50000, orbitSpeed: 0.000012, rotationSpeed: 0.03 },
            ];

            const planets = [];
            const allPlanetMeshes = [sun];
            const allInteractableObjects = [sun];

            planetsData.forEach((data) => {
                const orbit = new THREE.Object3D();
                solarSystemGroup.add(orbit);

                const geometry = new THREE.IcosahedronGeometry(data.size, 2);
                const material = new THREE.MeshBasicMaterial({
                    color: data.color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                const planet = new THREE.Mesh(geometry, material);
                planet.position.x = data.distance;
                planet.name = data.name;
                planet.userData.radius = data.size;
                planet.userData.initialScale = new THREE.Vector3(1, 1, 1);
                orbit.add(planet);
                allPlanetMeshes.push(planet);
                allInteractableObjects.push(planet);

                if (data.hasRings) {
                    let ringGeometry, ringMaterial, ringMesh;
                    if (data.name === 'Saturn') {
                        ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                        ringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                        ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                        ringMesh.rotation.x = Math.PI / 2;
                        ringMesh.rotation.y = Math.PI / 4;
                        planet.add(ringMesh);
                    } else if (data.name === 'Uranus') {
                        ringGeometry = new THREE.RingGeometry(data.size * 1.2, data.size * 1.8, 64);
                        ringMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                        ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                        ringMesh.rotation.x = Math.PI / 2;
                        ringMesh.rotation.z = Math.PI / 2;
                        planet.add(ringMesh);
                    }
                }

                const points = [];
                const segments = 128;
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance));
                }
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 1 });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                solarSystemGroup.add(orbitLine);

                planets.push({
                    mesh: planet,
                    orbit: orbit,
                    orbitSpeed: data.orbitSpeed,
                    rotationSpeed: data.rotationSpeed,
                    size: data.size
                });
            });

            // --- Star Field Creation ---
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 500000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200000000);
                const y = THREE.MathUtils.randFloatSpread(200000000);
                const z = THREE.MathUtils.randFloatSpread(200000000);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 5 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // --- Galaxy Creation (Fire Lily style wireframe) ---
            const galaxyGroup = new THREE.Group();
            scene.add(galaxyGroup);

            const galaxySize = 100000000;
            const spiralArms = 6;
            const armTightness = 1.5;
            const coreRadius = 15000000;
            const petalHeight = 0.5;

            // Create the galaxy core as a dense set of points
            const coreVertices = [];
            const coreColors = [];
            for (let i = 0; i < 200000; i++) {
                const distance = Math.random() * coreRadius;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * distance;
                const y = (Math.random() - 0.5) * distance / 10;
                const z = Math.sin(angle) * distance;
                coreVertices.push(x, y, z);
                
                const color = new THREE.Color();
                const t = distance / coreRadius;
                color.setRGB(1, 1 - 0.5 * t, 0.5 - 0.5 * t);
                coreColors.push(color.r, color.g, color.b);
            }
            const coreGeometry = new THREE.BufferGeometry();
            coreGeometry.setAttribute('position', new THREE.Float32BufferAttribute(coreVertices, 3));
            coreGeometry.setAttribute('color', new THREE.Float32BufferAttribute(coreColors, 3));
            const coreMaterial = new THREE.PointsMaterial({
                size: 5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            const galaxyCore = new THREE.Points(coreGeometry, coreMaterial);
            galaxyGroup.add(galaxyCore);

            // Create the spiral arms as wireframes
            const armPointCount = 20000; // Increased density
            const armMaterial = new THREE.LineBasicMaterial({
                color: 0xff4500, // Fiery orange
                transparent: true,
                opacity: 1
            });
            for (let i = 0; i < spiralArms; i++) {
                const points = [];
                for (let j = 0; j < armPointCount; j++) {
                    const t = j / armPointCount;
                    const distance = coreRadius + t * (galaxySize - coreRadius);
                    const armAngle = (i * Math.PI * 2 / spiralArms) + distance / galaxySize * Math.PI * 2 * armTightness;
                    
                    const x = Math.cos(armAngle) * distance;
                    const y = (Math.random() - 0.5) * distance / 50 * petalHeight;
                    const z = Math.sin(armAngle) * distance;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, armMaterial);
                galaxyGroup.add(line);
            }


            // --- Black Hole Generation ---
            const blackHoles = [];
            const numBlackHoles = 5;
            const blackHoleRadius = 5000;
            const blackHoleParticleCount = 10000;

            for (let i = 0; i < numBlackHoles; i++) {
                const position = new THREE.Vector3(
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.8),
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.1),
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.8)
                );
                
                // Black hole core
                const coreGeometry = new THREE.SphereGeometry(blackHoleRadius, 32, 32);
                const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.copy(position);
                core.name = `Black Hole ${i + 1}`; // Added name for pointer
                core.userData.radius = blackHoleRadius;
                scene.add(core);
                allInteractableObjects.push(core);

                // Accretion disk particles
                const particleGeometry = new THREE.BufferGeometry();
                const particleVertices = [];
                for (let j = 0; j < blackHoleParticleCount; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = blackHoleRadius + Math.random() * blackHoleRadius * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    particleVertices.push(x, 0, z);
                }
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
                const particleMaterial = new THREE.PointsMaterial({ color: 0xffa500, size: 20, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.5 });
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                particles.position.copy(position);
                scene.add(particles);

                blackHoles.push({ core, particles });
            }
            
            // Re-populate allInteractableObjects to include the sun
            allInteractableObjects.push(sun);

            // --- Exploding Stars (Boomerang Animation) ---
            const explodingStars = [];
            function createExplosion(position) {
                const particleCount = 200;
                const explosionParticles = new THREE.BufferGeometry();
                const explosionVertices = [];
                const explosionVelocities = [];
                const maxDistance = 20000;
                const duration = 2000;
                
                for (let i = 0; i < particleCount; i++) {
                    explosionVertices.push(0, 0, 0);
                    const velocity = new THREE.Vector3(
                        THREE.MathUtils.randFloatSpread(100),
                        THREE.MathUtils.randFloatSpread(100),
                        THREE.MathUtils.randFloatSpread(100)
                    ).normalize().multiplyScalar(Math.random() * 50);
                    explosionVelocities.push(velocity);
                }
                explosionParticles.setAttribute('position', new THREE.Float32BufferAttribute(explosionVertices, 3));
                
                const explosionMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 50, blending: THREE.AdditiveBlending, transparent: true });
                const explosionMesh = new THREE.Points(explosionParticles, explosionMaterial);
                explosionMesh.position.copy(position);
                scene.add(explosionMesh);
                
                const explosion = {
                    mesh: explosionMesh,
                    velocities: explosionVelocities,
                    timer: 0,
                    duration,
                    maxDistance,
                    isGrowing: true,
                };
                explodingStars.push(explosion);
            }

            // Trigger explosions randomly
            setInterval(() => {
                const explosionPosition = new THREE.Vector3(
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.9),
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.2),
                    THREE.MathUtils.randFloatSpread(galaxySize * 0.9)
                );
                createExplosion(explosionPosition);
            }, 5000);

            // --- Mini-map Objects ---
            const minimapSun = new THREE.Mesh(new THREE.IcosahedronGeometry(20, 5), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            minimapScene.add(minimapSun);
            const minimapPlanets = [];
            planetsData.forEach((data) => {
                const minimapPlanet = new THREE.Mesh(new THREE.SphereGeometry(data.size, 32, 32), new THREE.MeshBasicMaterial({ color: data.color }));
                minimapPlanet.position.x = data.distance;
                minimapScene.add(minimapPlanet);
                minimapPlanets.push(minimapPlanet);

                const points = [];
                const segments = 128;
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance));
                }
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 1 });
                const minimapOrbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                minimapScene.add(minimapOrbitLine);

                if (data.hasRings) {
                    let ringGeometry, ringMaterial, ringMesh;
                    if (data.name === 'Saturn') {
                        ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                        ringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
                        ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                        ringMesh.rotation.x = Math.PI / 2;
                        ringMesh.rotation.y = Math.PI / 4;
                        minimapPlanet.add(ringMesh);
                    } else if (data.name === 'Uranus') {
                        ringGeometry = new THREE.RingGeometry(data.size * 1.2, data.size * 1.8, 64);
                        ringMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
                        ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                        ringMesh.rotation.x = Math.PI / 2;
                        ringMesh.rotation.z = Math.PI / 2;
                        minimapPlanet.add(ringMesh);
                    }
                }
            });

            const cameraIconGeometry = new THREE.ConeGeometry(5, 10, 8);
            const cameraIconMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const cameraIcon = new THREE.Mesh(cameraIconGeometry, cameraIconMaterial);
            minimapScene.add(cameraIcon);

            // POV Menu and Buttons
            const povMenu = document.getElementById('pov-menu');
            const infoBox = document.getElementById('info-box');
            const facingButtonsContainer = document.createElement('div');
            facingButtonsContainer.id = 'facing-buttons';
            povMenu.appendChild(facingButtonsContainer);

            let focusedBody = null;
            let cameraMode = 'global';
            let selectedPlanet = null;
            
            const cameraModeText = document.getElementById('camera-mode-text');
            const focusedBodyText = document.getElementById('focused-body-text');

            const setActiveButton = (button) => {
                document.querySelectorAll('.planet-button').forEach(btn => btn.classList.remove('active'));
                if (button) {
                    button.classList.add('active');
                }
            };
            
            const updateUI = () => {
                cameraModeText.textContent = cameraMode.charAt(0).toUpperCase() + cameraMode.slice(1);
                focusedBodyText.textContent = focusedBody ? focusedBody.name : 'None';
            };

            const selectBody = (body) => {
                selectedPlanet = body;
            };

            const solarSystemButton = document.createElement('button');
            solarSystemButton.textContent = 'Solar System';
            solarSystemButton.classList.add('planet-button');
            solarSystemButton.addEventListener('click', () => {
                focusedBody = null;
                cameraMode = 'global';
                facingButtonsContainer.style.display = 'none';
                infoBox.style.display = 'none';
                planets.forEach(p => {
                    p.mesh.material.side = THREE.FrontSide;
                    p.mesh.material.opacity = 0.2;
                    p.mesh.material.wireframe = true;
                });
                selectBody(null);
                controls.enabled = true;
                controls.reset();
                setActiveButton(solarSystemButton);
                updateUI();
            });
            povMenu.appendChild(solarSystemButton);

            const sunButton = document.createElement('button');
            sunButton.textContent = 'Sun';
            sunButton.classList.add('planet-button');
            sunButton.addEventListener('click', () => {
                focusedBody = sun;
                cameraMode = 'following';
                facingButtonsContainer.style.display = 'none';
                infoBox.style.display = 'none';
                planets.forEach(p => {
                    p.mesh.material.side = THREE.FrontSide;
                    p.mesh.material.opacity = 0.2;
                    p.mesh.material.wireframe = true;
                });
                selectBody(sun);
                controls.enabled = false;
                setActiveButton(sunButton);
                updateUI();
            });
            povMenu.appendChild(sunButton);

            planetsData.forEach((data, index) => {
                const button = document.createElement('button');
                button.textContent = data.name;
                button.classList.add('planet-button');
                button.addEventListener('click', () => {
                    focusedBody = planets[index].mesh;
                    cameraMode = 'following';
                    facingButtonsContainer.style.display = 'flex';
                    infoBox.style.display = 'none';
                    planets.forEach(p => {
                        p.mesh.material.side = THREE.FrontSide;
                        p.mesh.material.opacity = 0.2;
                        p.mesh.material.wireframe = true;
                    });
                    selectBody(planets[index].mesh);
                    controls.enabled = false;
                    setActiveButton(button);
                    updateUI();
                });
                povMenu.appendChild(button);
            });

            const facingSunButton = document.createElement('button');
            facingSunButton.textContent = 'Orbiting Sun';
            facingSunButton.classList.add('facing-button');
            facingSunButton.addEventListener('click', () => {
                cameraMode = 'global';
                infoBox.style.display = 'none';
                controls.enabled = true;
                if (focusedBody) {
                    const planetWorldPosition = new THREE.Vector3();
                    focusedBody.getWorldPosition(planetWorldPosition);
                    const sunToPlanetVector = planetWorldPosition.clone().sub(sun.position).normalize();
                    const distanceOffset = focusedBody.userData.radius * 2000;
                    const cameraTargetPosition = planetWorldPosition.clone().add(sunToPlanetVector.multiplyScalar(distanceOffset));
                    camera.position.copy(cameraTargetPosition);
                    controls.target.copy(planetWorldPosition);
                    controls.update();
                }
                updateUI();
            });
            facingButtonsContainer.appendChild(facingSunButton);

            const orbitingPlanetButton = document.createElement('button');
            orbitingPlanetButton.textContent = 'Orbiting Planet';
            orbitingPlanetButton.classList.add('facing-button');
            orbitingPlanetButton.addEventListener('click', () => {
                cameraMode = 'global';
                infoBox.style.display = 'none';
                controls.enabled = true;
                if (focusedBody) {
                    const planetWorldPosition = new THREE.Vector3();
                    focusedBody.getWorldPosition(planetWorldPosition);
                    const planetOrbit = focusedBody.parent;
                    const cameraOffset = new THREE.Vector3(0, focusedBody.userData.radius * 50, -focusedBody.userData.radius * 100);
                    const cameraPosition = new THREE.Vector3().copy(planetWorldPosition).add(cameraOffset.applyQuaternion(planetOrbit.quaternion));
                    camera.position.copy(cameraPosition);
                    controls.target.copy(planetWorldPosition);
                    controls.update();
                }
                updateUI();
            });
            facingButtonsContainer.appendChild(orbitingPlanetButton);

            const insidePlanetButton = document.createElement('button');
            insidePlanetButton.textContent = 'Inside the planet';
            insidePlanetButton.classList.add('facing-button');
            insidePlanetButton.addEventListener('click', () => {
                cameraMode = 'inside';
                infoBox.style.display = 'block';
                planets.forEach(p => {
                    p.mesh.material.side = THREE.BackSide;
                    p.mesh.material.opacity = 0.2;
                    p.mesh.material.wireframe = true;
                });
                if (focusedBody) {
                    const material = focusedBody.material;
                    material.side = THREE.BackSide;
                    material.wireframe = true;
                    material.transparent = true;
                    material.opacity = 0.2;
                }
                controls.enabled = false;
                updateUI();
            });
            facingButtonsContainer.appendChild(insidePlanetButton);
            
            // Add black hole buttons
            blackHoles.forEach((bh, index) => {
                const button = document.createElement('button');
                button.textContent = bh.core.name;
                button.classList.add('planet-button');
                button.addEventListener('click', () => {
                    focusedBody = bh.core;
                    cameraMode = 'global'; // Switch to global camera for black holes
                    facingButtonsContainer.style.display = 'none';
                    infoBox.style.display = 'none';
                    planets.forEach(p => {
                        p.mesh.material.side = THREE.FrontSide;
                        p.mesh.material.opacity = 0.2;
                        p.mesh.material.wireframe = true;
                    });
                    selectBody(bh.core);
                    controls.enabled = true; // Enable orbit controls
                    controls.target.copy(bh.core.position); // Set camera target to black hole
                    setActiveButton(button);
                    updateUI();
                });
                povMenu.appendChild(button);
            });

            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                if (cameraMode !== 'inside') return;
                isDragging = true;
                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging || cameraMode !== 'inside') return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                camera.rotation.y += deltaX * 0.005;
                camera.rotation.x += deltaY * 0.005;

                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });

            // Touch event listeners for Inside the Planet mode
            let isTouching = false;
            let touchPrevious = { x: 0, y: 0 };

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (cameraMode !== 'inside') return;
                isTouching = true;
                const touch = e.touches[0];
                touchPrevious.x = touch.clientX;
                touchPrevious.y = touch.clientY;
            });

            renderer.domElement.addEventListener('touchend', () => {
                isTouching = false;
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!isTouching || cameraMode !== 'inside') return;
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchPrevious.x;
                const deltaY = touch.clientY - touchPrevious.y;

                camera.rotation.y += deltaX * 0.005;
                camera.rotation.x += deltaY * 0.005;

                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                touchPrevious.x = touch.clientX;
                touchPrevious.y = touch.clientY;
            });


            const syncMinimap = function() {
                minimapSun.position.copy(sun.position);

                planets.forEach((p, index) => {
                    const worldPosition = new THREE.Vector3();
                    p.mesh.getWorldPosition(worldPosition);
                    minimapPlanets[index].position.copy(worldPosition);
                });

                const mainCameraPosition = new THREE.Vector3();
                camera.getWorldPosition(mainCameraPosition);
                cameraIcon.position.set(mainCameraPosition.x, mainCameraPosition.z, 0);

                const mainCameraDirection = new THREE.Vector3();
                camera.getWorldDirection(mainCameraDirection);
                cameraIcon.rotation.y = Math.atan2(mainCameraDirection.x, mainCameraDirection.z) + Math.PI / 2;
                cameraIcon.rotation.x = Math.PI / 2;
            };

            // Main Animation Loop
            function animateLoop() {
                requestAnimationFrame(animateLoop);

                sun.rotation.y += 0.001;
                planets.forEach(p => {
                    p.orbit.rotation.y += p.orbitSpeed;
                    p.mesh.rotation.y += p.rotationSpeed;
                });
                
                // Animate black hole accretion disks
                const blackHoleRotationSpeed = 0.02;
                const time = Date.now() * 0.0005;
                blackHoles.forEach(bh => {
                    // Swirl the particles
                    bh.particles.rotation.y += blackHoleRotationSpeed;
                    
                    // Create a subtle pulsating effect for the particles
                    bh.particles.material.opacity = 0.5 + Math.sin(time) * 0.2;

                    // Make the labels always face the camera
                    bh.core.children.forEach(child => {
                        if (child.isMesh && child.geometry.type === 'TextGeometry') {
                            child.lookAt(camera.position);
                        }
                    });
                });

                // Make planet and sun labels always face the camera
                planets.forEach(p => {
                    p.mesh.children.forEach(child => {
                        if (child.isMesh && child.geometry.type === 'TextGeometry') {
                            child.lookAt(camera.position);
                        }
                    });
                });
                sun.children.forEach(child => {
                    if (child.isMesh && child.geometry.type === 'TextGeometry') {
                        child.lookAt(camera.position);
                    }
                });

                // Animate exploding stars
                for (let i = explodingStars.length - 1; i >= 0; i--) {
                    const explosion = explodingStars[i];
                    explosion.timer += 16;
                    const progress = explosion.timer / explosion.duration;
                    
                    const positions = explosion.mesh.geometry.attributes.position.array;
                    const velocities = explosion.velocities;

                    let isFinished = true;
                    for (let j = 0; j < positions.length; j += 3) {
                        const startX = velocities[j/3].x * progress;
                        const startY = velocities[j/3].y * progress;
                        const startZ = velocities[j/3].z * progress;

                        if (explosion.isGrowing) {
                            positions[j] = startX;
                            positions[j+1] = startY;
                            positions[j+2] = startZ;
                            if (progress >= 1) {
                                explosion.isGrowing = false;
                                explosion.timer = 0;
                            }
                        } else {
                            positions[j] = startX * (1 - progress);
                            positions[j+1] = startY * (1 - progress);
                            positions[j+2] = startZ * (1 - progress);
                        }

                        if (explosion.isGrowing || positions[j] !== 0 || positions[j+1] !== 0 || positions[j+2] !== 0) {
                            isFinished = false;
                        }
                    }
                    explosion.mesh.geometry.attributes.position.needsUpdate = true;
                    
                    if (!explosion.isGrowing) {
                        explosion.mesh.material.opacity = 1 - progress;
                    }

                    if (isFinished) {
                        scene.remove(explosion.mesh);
                        explodingStars.splice(i, 1);
                    }
                }

                const targetPosition = new THREE.Vector3();
                if (focusedBody) {
                    focusedBody.getWorldPosition(targetPosition);
                }


                if (cameraMode === 'global') {
                    if (focusedBody && !focusedBody.name.includes('Black Hole')) {
                        controls.target.lerp(focusedBody.getWorldPosition(new THREE.Vector3()), 0.1);
                    }
                    controls.update();
                } else if (cameraMode === 'following') {
                    if (focusedBody.name === 'Sun') {
                        const sunOrbitPosition = new THREE.Vector3(15000 * Math.cos(Date.now() * 0.00001), 7000, 15000 * Math.sin(Date.now() * 0.00001));
                        camera.position.lerp(sunOrbitPosition, 0.1);
                        camera.lookAt(targetPosition);
                    } else {
                        const planetWorldPosition = new THREE.Vector3();
                        focusedBody.getWorldPosition(planetWorldPosition);
                        const sunToPlanetVector = planetWorldPosition.clone().sub(sun.position).normalize();
                        const distanceOffset = focusedBody.userData.radius * 2000;
                        const cameraTargetPosition = planetWorldPosition.clone().add(sunToPlanetVector.multiplyScalar(distanceOffset));
                        camera.position.lerp(cameraTargetPosition, 0.1);
                        camera.lookAt(sun.position);
                    }
                } else if (cameraMode === 'inside') {
                    if (focusedBody) {
                        camera.near = 0.01;
                        camera.far = focusedBody.userData.radius * 2;
                        camera.updateProjectionMatrix();
                        const planetPosition = new THREE.Vector3();
                        focusedBody.getWorldPosition(planetPosition);
                        camera.position.copy(planetPosition);
                    }
                }

                renderer.render(scene, camera);
                syncMinimap();
                minimapRenderer.render(minimapScene, minimapCamera);
            }

            // Window Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                minimapRenderer.setSize(minimapContainer.offsetWidth, minimapContainer.offsetHeight);
            });

            animateLoop();
            updateUI();
        };
    </script>
</body>
</html>
