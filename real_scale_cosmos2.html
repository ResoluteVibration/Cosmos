<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System & Galaxy Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        .planet-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: flex-start; /* Aligned to start for scrolling */
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 10;
            overflow-x: auto;
            max-width: 95%;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on mobile */
        }
        
        /* Custom scrollbar for better aesthetics */
        .planet-controls::-webkit-scrollbar {
            height: 8px;
        }

        .planet-controls::-webkit-scrollbar-track {
            background: #222;
            border-radius: 10px;
        }

        .planet-controls::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 10px;
        }

        .planet-controls::-webkit-scrollbar-thumb:hover {
            background: #777;
        }


        .planet-button {
            padding: 6px 12px;
            font-size: 0.85em;
            cursor: pointer;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 20px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .planet-button.active,
        .planet-button:hover {
            background-color: #ffcc00;
            color: #000;
            box-shadow: 0 4px 15px rgba(255, 204, 0, 0.4);
            border-color: #ffcc00;
        }
        
        #solar-system-buttons {
            display: none; /* Hidden by default */
            flex-direction: row;
            gap: 8px;
        }

        .options-container {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(150%);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease;
            display: flex;
            flex-direction: row;
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 10;
        }

        .options-container.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        #camera-options, .follow-modes {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        #view-toggle-button,
        #follow-button {
            padding: 8px 15px;
            font-size: 0.9em;
            cursor: pointer;
            border: none;
            border-radius: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 204, 0, 0.4);
        }

        #view-toggle-button {
            background-color: #ffcc00;
            color: #000;
        }

        #view-toggle-button:hover {
            background-color: #e6b800;
            box-shadow: 0 6px 20px rgba(255, 204, 0, 0.6);
        }

        #follow-button {
            background-color: #00aaff;
            color: #fff;
        }
        
        #follow-button:hover {
            background-color: #0088cc;
            box-shadow: 0 6px 20px rgba(0, 170, 255, 0.6);
        }

        .follow-modes {
            display: none;
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #444;
        }

        .follow-modes button {
            padding: 6px 12px;
            font-size: 0.85em;
            cursor: pointer;
            background-color: #555;
            color: #fff;
            border: 1px solid #777;
            border-radius: 20px;
            transition: all 0.2s ease;
        }
        
        .follow-modes button.active,
        .follow-modes button:hover {
            background-color: #00aaff;
            box-shadow: 0 4px 15px rgba(0, 170, 255, 0.4);
            border-color: #00aaff;
        }

        #selected-celestial-name {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.8em;
            font-weight: bold;
            color: #ffcc00;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="bottom-options-container" class="options-container">
        <div id="camera-options">
            <button id="view-toggle-button">Switch to Inside View</button>
            <button id="follow-button">Follow Planet</button>
        </div>
        <div class="follow-modes" id="follow-modes">
            <button id="face-sun-button" class="active">Face Sun</button>
            <button id="from-front-button">From Front</button>
            <button id="from-behind-button">From Behind</button>
            <button id="free-look-button">Rotational View with Free Look</button>
        </div>
    </div>
    <div class="planet-controls" id="planet-controls"></div>
    <div id="selected-celestial-name">Solar System Simulation</div>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- TextGeometry & FontLoader for 3D text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>
    <!-- lil-gui for controls -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <!-- Anime.js for galaxy animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    
    <script>
        window.onload = function() {
            // === Basic Scene Setup ===
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000000);
            const renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);

            const pointLight = new THREE.PointLight(0xffffff, 1, 0, 2);
            scene.add(pointLight);

            const solarSystemGroup = new THREE.Group();
            solarSystemGroup.position.set(2500000, 10000, 0);
            scene.add(solarSystemGroup);

            // === Sun Creation ===
            const sunRadius = 50; 
            const sunGeometry = new THREE.IcosahedronGeometry(sunRadius, 5); 
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: true, transparent: true, opacity: 0.1 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.name = 'Sun';
            solarSystemGroup.add(sun);

            // === Planet Data and Scaling ===
            const AU_SCALE = 250;
            const PLANET_SIZE_SCALE = 5;
            const planetsData = [
                { name: 'Mercury', au: 0.39, radius: 0.38, color: 0x888888, period: 0.24 * 2, rotationPeriod: 5 * 2 },
                { name: 'Venus', au: 0.72, radius: 0.95, color: 0xaaaaaa, period: 0.62 * 2, rotationPeriod: 7 * 2 },
                { name: 'Earth', au: 1.0, radius: 1.0, color: 0x00aaff, period: 1.0 * 2, rotationPeriod: 2 * 2 },
                { name: 'Mars', au: 1.52, radius: 0.53, color: 0xff5500, period: 1.88 * 2, rotationPeriod: 3 * 2 },
                { name: 'Jupiter', au: 5.2, radius: 11.2, color: 0xffaa00, period: 11.86 * 2, rotationPeriod: 1 * 2 },
                { name: 'Saturn', au: 9.54, radius: 9.45, color: 0xccccaa, period: 29.46 * 2, rotationPeriod: 1 * 2, hasRings: true, tilt: Math.PI / 6 },
                { name: 'Uranus', au: 19.2, radius: 4.0, color: 0x00ffff, period: 84.01 * 2, rotationPeriod: 4 * 2, hasRings: true, tilt: Math.PI / 2 },
                { name: 'Neptune', au: 30.1, radius: 3.88, color: 0x0000ff, period: 164.79 * 2, rotationPeriod: 4 * 2 },
                { name: 'Pluto', au: 39.5, radius: 0.18, color: 0x996633, period: 248.0 * 2, rotationPeriod: 8 * 2 }
            ];

            // === Moon Data ===
            const moonsData = [
                { name: 'Moon', parent: 'Earth', radius: 0.27, orbitRadius: 2.5, period: 27.3 * 2, color: 0xcccccc },
                { name: 'Phobos', parent: 'Mars', radius: 0.001, orbitRadius: 0.1, period: 0.3 * 2, color: 0x996633 },
                { name: 'Deimos', parent: 'Mars', radius: 0.001, orbitRadius: 0.15, period: 1.3 * 2, color: 0x996633 },
                { name: 'Io', parent: 'Jupiter', radius: 0.28, orbitRadius: 15, period: 1.8 * 2, color: 0xffa500 },
                { name: 'Europa', parent: 'Jupiter', radius: 0.25, orbitRadius: 20, period: 3.6 * 2, color: 0xaaaaaa },
                { name: 'Ganymede', parent: 'Jupiter', radius: 0.41, orbitRadius: 28, period: 7.2 * 2, color: 0xeeeeee },
                { name: 'Callisto', parent: 'Jupiter', radius: 0.38, orbitRadius: 38, period: 16.7 * 2, color: 0xaaaa99 },
                { name: 'Titan', parent: 'Saturn', radius: 0.4, orbitRadius: 25, period: 16 * 2, color: 0xdddd99 },
                { name: 'Rhea', parent: 'Saturn', radius: 0.12, orbitRadius: 18, period: 4.5 * 2, color: 0xcccccc },
                { name: 'Iapetus', parent: 'Saturn', radius: 0.11, orbitRadius: 40, period: 79 * 2, color: 0x999999 },
                { name: 'Titania', parent: 'Uranus', radius: 0.12, orbitRadius: 10, period: 8.7 * 2, color: 0x00aaff },
                { name: 'Oberon', parent: 'Uranus', radius: 0.11, orbitRadius: 15, period: 13.5 * 2, color: 0x9999cc },
                { name: 'Triton', parent: 'Neptune', radius: 0.21, orbitRadius: 12, period: 5.9 * 2, color: 0x0099ff },
                { name: 'Charon', parent: 'Pluto', radius: 0.09, orbitRadius: 4, period: 6.4 * 2, color: 0x996633 }
            ];
            
            const planets = [];
            let celestialBodies = {};
            const celestialLabels = [];
            
            // === 3D Text Creation ===
            const loader = new THREE.FontLoader();
            loader.load('https://raw.githubusercontent.com/mrdoob/three.js/r128/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const createLabel = (text, size) => {
                    const textGeometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: size,
                        height: size / 10,
                        curveSegments: 12,
                        bevelEnabled: false,
                    });
                    textGeometry.center();
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.8
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    return textMesh;
                };

                setTimeout(() => {
                    const labelsGroup = new THREE.Group();
                    Object.entries(celestialBodies).forEach(([name, object]) => {
                        if (name === 'Galaxy' || name === 'Asteroid Belt' || !object.geometry) return;

                        const radius = object.geometry.parameters.radius || 50;
                        const label = createLabel(name.toUpperCase(), radius); // Set base size to radius
                        labelsGroup.add(label);
                        celestialLabels.push({ label, target: object });
                    });
                    scene.add(labelsGroup);
                }, 500); 
            });

            // === Galaxy Generation ===
            let galaxyParticles = null;
            const galaxyParameters = { count: 200000, size: 50, radius: 10000000, branches: 5, spin: 0.5, randomness: 0.8, randomnessPower: 4, insideColor: '#ff9933', outsideColor: '#3300cc' };
            const generateGalaxy = () => {
                if (galaxyParticles) { scene.remove(galaxyParticles); galaxyParticles.geometry.dispose(); galaxyParticles.material.dispose(); }
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(galaxyParameters.count * 3);
                const colors = new Float32Array(galaxyParameters.count * 3);
                const colorInside = new THREE.Color(galaxyParameters.insideColor);
                const colorOutside = new THREE.Color(galaxyParameters.outsideColor);
                for (let i = 0; i < galaxyParameters.count; i++) {
                    const i3 = i * 3;
                    const radius = Math.random() * galaxyParameters.radius;
                    const spinAngle = radius * galaxyParameters.spin * 0.00001;
                    const branchAngle = (i % galaxyParameters.branches) / galaxyParameters.branches * Math.PI * 2;
                    const randomX = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParameters.randomness * radius;
                    const randomY = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParameters.randomness * radius * 0.1;
                    const randomZ = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParameters.randomness * radius;
                    positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                    positions[i3 + 1] = randomY;
                    positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                    const mixedColor = colorInside.clone().lerp(colorOutside, radius / galaxyParameters.radius);
                    colors[i3] = mixedColor.r; colors[i3 + 1] = mixedColor.g; colors[i3 + 2] = mixedColor.b;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const material = new THREE.PointsMaterial({ size: galaxyParameters.size, sizeAttenuation: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true });
                galaxyParticles = new THREE.Points(geometry, material);
                galaxyParticles.name = 'Galaxy';
                scene.add(galaxyParticles);
            };
            generateGalaxy();

            // === GUI Controls ===
            const gui = new lil.GUI({ title: 'Galaxy Controls' });
            gui.add(galaxyParameters, 'count', 10000, 1000000, 1000).name('Star Count').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'size', 50, 100000, 100).name('Star Size').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'radius', 100000, 20000000, 10000).name('Galaxy Radius').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'branches', 2, 20, 1).name('Branches').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'spin', -5, 5, 0.001).name('Spin').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'randomness', 0, 2, 0.001).name('Randomness').onFinishChange(generateGalaxy);
            gui.add(galaxyParameters, 'randomnessPower', 1, 10, 0.001).name('Randomness Power').onFinishChange(generateGalaxy);
            gui.addColor(galaxyParameters, 'insideColor').name('Core Color').onFinishChange(generateGalaxy);
            gui.addColor(galaxyParameters, 'outsideColor').name('Outer Color').onFinishChange(generateGalaxy);

            // === Animation with Anime.js ===
            const animationState = { rotationY: 0 };
            anime({ targets: animationState, rotationY: Math.PI * 2, duration: 500000, easing: 'linear', loop: true });

            // === Helper Functions for Solar System Creation ===
            function createRings(innerRadius, outerRadius, color) {
                const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                ringMesh.rotation.x = Math.PI / 2;
                return ringMesh;
            }
            function createOrbitAndPlanet(planetData) {
                const orbitRadius = planetData.au * AU_SCALE;
                const points = Array.from({ length: 129 }, (_, i) => new THREE.Vector3(orbitRadius * Math.cos((i / 128) * Math.PI * 2), 0, orbitRadius * Math.sin((i / 128) * Math.PI * 2)));
                const orbit = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: planetData.color }));
                solarSystemGroup.add(orbit);
                const planetRadius = planetData.radius * PLANET_SIZE_SCALE;
                const planet = new THREE.Mesh(new THREE.SphereGeometry(planetRadius, 32, 32), new THREE.MeshBasicMaterial({ color: planetData.color, wireframe: true, transparent: true, opacity: 0.8 }));
                planet.name = planetData.name;
                solarSystemGroup.add(planet);
                let rings = null;
                if (planetData.hasRings) { rings = createRings(planetRadius * 1.5, planetRadius * 2.5, planetData.color); planet.add(rings); }
                return { mesh: planet, orbitRadius, period: planetData.period, rotationPeriod: planetData.rotationPeriod, details: planetData, rings: rings };
            }
            planetsData.forEach(data => planets.push(createOrbitAndPlanet(data)));

            function createMoons(moonsData) {
                 return moonsData.map(moonData => {
                    const parentPlanet = planets.find(p => p.details.name === moonData.parent);
                    if (!parentPlanet) return null;
                    const moon = new THREE.Mesh(new THREE.SphereGeometry(moonData.radius * PLANET_SIZE_SCALE, 32, 32), new THREE.MeshBasicMaterial({ color: moonData.color, wireframe: true, transparent: true, opacity: 0.8 }));
                    moon.name = moonData.name;
                    solarSystemGroup.add(moon);
                    const orbitRadius = moonData.orbitRadius * PLANET_SIZE_SCALE;
                    const points = Array.from({ length: 65 }, (_, i) => {
                        const theta = (i / 64) * Math.PI * 2;
                        return new THREE.Vector3(orbitRadius * Math.cos(theta), 0, orbitRadius * Math.sin(theta));
                    });
                    const orbit = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: moonData.color, transparent: true, opacity: 0.3 }));
                    solarSystemGroup.add(orbit);
                    return { mesh: moon, orbitRadius, period: moonData.period, parentMesh: parentPlanet.mesh, orbitMesh: orbit };
                }).filter(m => m);
            }
            const createdMoons = createMoons(moonsData);

            function createAsteroidBelt(minRadius, maxRadius, count) {
                const vertices = [];
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = THREE.MathUtils.randFloat(minRadius, maxRadius);
                    const yOffset = THREE.MathUtils.randFloatSpread(5);
                    vertices.push(radius * Math.cos(angle), yOffset, radius * Math.sin(angle));
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const asteroids = new THREE.Points(geometry, new THREE.PointsMaterial({ color: 0x808080, size: 0.2 }));
                asteroids.name = 'Asteroid Belt';
                solarSystemGroup.add(asteroids);
                return { mesh: asteroids, period: 5.6 * 8 };
            }
            const asteroidBelt = createAsteroidBelt(1.52 * AU_SCALE + 20, 5.2 * AU_SCALE - 20, 5000);
            
            // === Black Hole and Supernova Creation ===
            const blackHoles = [];
            const explodingStars = [];
            const createBlackHole = (name, position) => {
                const core = new THREE.Mesh(new THREE.SphereGeometry(200, 32, 32), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                core.position.copy(position);
                core.name = name;
                scene.add(core);
                const vertices = [];
                for (let i = 0; i < 5000; i++) {
                    const r = 200 + Math.random() * 300;
                    const angle = Math.random() * Math.PI * 2;
                    vertices.push(Math.cos(angle) * r, 0, Math.sin(angle) * r);
                }
                const geom = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const particles = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xffa500, size: 5, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.5 }));
                particles.position.copy(position);
                scene.add(particles);
                blackHoles.push({ core, particles });
                return core;
            };
            
            const createExplosion = (position) => {
                const geom = new THREE.BufferGeometry();
                const vertices = new Float32Array(200 * 3);
                geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const mesh = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xffffff, size: 50, blending: THREE.AdditiveBlending, transparent: true, opacity: 1.0 }));
                mesh.position.copy(position);
                scene.add(mesh);
                const explosion = {
                    mesh,
                    velocities: Array.from({length: 200}, () => new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize().multiplyScalar(Math.random() * 50)),
                    startTime: Date.now(),
                };
                explodingStars.push(explosion);
            };
            setInterval(() => createExplosion(new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(galaxyParameters.radius * 1.8),
                THREE.MathUtils.randFloatSpread(galaxyParameters.radius * 0.2),
                THREE.MathUtils.randFloatSpread(galaxyParameters.radius * 1.8)
            )), 5000);
            
            // === Camera and UI Logic ===
            let isDragging = false, previousMousePosition = { x: 0, y: 0 };
            let horizontalAngle = Math.random() * Math.PI * 2, verticalAngle = (Math.random() - 0.5) * Math.PI;
            let cameraDistance = 10000;
            let focusedObject = sun;
            let cameraMode = 'orbital', followingMode = 'face-sun', currentPlanetIndex = null;
            let cameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');
            const rotationSensitivity = 0.005;
            let transitionState = { isTransitioning: false, startPosition: new THREE.Vector3(), endPosition: new THREE.Vector3(), startLookAt: new THREE.Vector3(), endLookAt: new THREE.Vector3(), startTime: 0, duration: 1500 };
            
            function updateCameraPosition() {
                if (transitionState.isTransitioning) {
                    const t = Math.min(1, (Date.now() - transitionState.startTime) / transitionState.duration);
                    const smoothT = t * t * (3 - 2 * t);
                    camera.position.lerpVectors(transitionState.startPosition, transitionState.endPosition, smoothT);
                    camera.lookAt(new THREE.Vector3().lerpVectors(transitionState.startLookAt, transitionState.endLookAt, smoothT));
                    if (t >= 1) {
                        transitionState.isTransitioning = false;
                        const worldPos = new THREE.Vector3();
                        focusedObject.getWorldPosition(worldPos);
                        cameraDistance = camera.position.distanceTo(worldPos);
                    }
                } else {
                    const targetPosition = new THREE.Vector3();
                    focusedObject.getWorldPosition(targetPosition);

                    if (cameraMode === 'inside') {
                        camera.position.copy(targetPosition);
                        camera.quaternion.setFromEuler(cameraEuler);
                    } else if (cameraMode === 'following' && currentPlanetIndex !== null) {
                        const planet = planets[currentPlanetIndex];
                        const planetPosition = new THREE.Vector3();
                        planet.mesh.getWorldPosition(planetPosition);
                        const sunPosition = new THREE.Vector3();
                        sun.getWorldPosition(sunPosition);
                        const vectorFromSun = planetPosition.clone().sub(sunPosition).normalize();
                        const forwardVector = new THREE.Vector3(-vectorFromSun.z, 0, vectorFromSun.x).normalize();
                        let cameraOffset, lookAtTarget = planetPosition;
                        switch (followingMode) {
                            case 'face-sun':
                                cameraOffset = forwardVector.clone().multiplyScalar(-cameraDistance);
                                cameraOffset.y += cameraDistance * 0.5;
                                lookAtTarget = sunPosition;
                                break;
                            case 'from-front':
                                cameraOffset = forwardVector.clone().multiplyScalar(-cameraDistance);
                                cameraOffset.y += cameraDistance * 0.5;
                                break;
                            case 'from-behind':
                                cameraOffset = forwardVector.clone().multiplyScalar(cameraDistance);
                                cameraOffset.y += cameraDistance * 0.5;
                                break;
                            case 'free-look':
                                const x_fl = cameraDistance * Math.sin(horizontalAngle) * Math.cos(verticalAngle);
                                const y_fl = cameraDistance * Math.sin(verticalAngle);
                                const z_fl = cameraDistance * Math.cos(horizontalAngle) * Math.cos(verticalAngle);
                                camera.position.set(x_fl, y_fl, z_fl).add(targetPosition);
                                lookAtTarget = targetPosition;
                                break;
                        }
                        if (followingMode !== 'free-look') {
                             camera.position.copy(planetPosition).add(cameraOffset);
                        }
                        camera.lookAt(lookAtTarget);
                    } else { // Orbital mode
                        const x = cameraDistance * Math.sin(horizontalAngle) * Math.cos(verticalAngle);
                        const y = cameraDistance * Math.sin(verticalAngle);
                        const z = cameraDistance * Math.cos(horizontalAngle) * Math.cos(verticalAngle);
                        camera.position.set(x, y, z).add(targetPosition);
                        camera.lookAt(targetPosition);
                    }
                }
            }

            document.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => {
                 if (!isDragging || transitionState.isTransitioning) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                if (cameraMode === 'inside') {
                    cameraEuler.y -= deltaX * rotationSensitivity;
                    cameraEuler.x -= deltaY * rotationSensitivity;
                    cameraEuler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraEuler.x));
                } else {
                    horizontalAngle -= deltaX * rotationSensitivity;
                    verticalAngle -= deltaY * rotationSensitivity;
                    verticalAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, verticalAngle));
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            document.addEventListener('wheel', (e) => {
                if (cameraMode !== 'inside') {
                    cameraDistance *= e.deltaY > 0 ? 1.05 : 1 / 1.05;
                    cameraDistance = Math.min(cameraDistance, 40000000);
                    cameraDistance = Math.max(cameraDistance, 0.1);
                }
            });

            const controlsContainer = document.getElementById('planet-controls');
            const bottomOptionsContainer = document.getElementById('bottom-options-container');
            const selectedCelestialName = document.getElementById('selected-celestial-name');
            const viewToggleButton = document.getElementById('view-toggle-button');
            const followButton = document.getElementById('follow-button');
            const followModesContainer = document.getElementById('follow-modes');
            
            function updateSelectedName(name) { selectedCelestialName.textContent = name; }
            
            function startTransition(newTarget, newDistance) {
                const newTargetPos = new THREE.Vector3();
                newTarget.getWorldPosition(newTargetPos);
                const oldTargetPos = new THREE.Vector3();
                focusedObject.getWorldPosition(oldTargetPos);

                transitionState = {
                    isTransitioning: true,
                    startLookAt: oldTargetPos.clone(),
                    endLookAt: newTargetPos.clone(),
                    startPosition: camera.position.clone(),
                    endPosition: newTargetPos.clone().add(new THREE.Vector3(newDistance * Math.sin(horizontalAngle) * Math.cos(verticalAngle), newDistance * Math.sin(verticalAngle), newDistance * Math.cos(horizontalAngle) * Math.cos(verticalAngle))),
                    startTime: Date.now(),
                    duration: 1500
                };
                focusedObject = newTarget;
            }

            function updateButtons(activeButton) {
                document.querySelectorAll('.planet-button').forEach(btn => btn.classList.remove('active'));
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }
            
            function updateUiForCameraMode() {
                const isPlanetFocused = planets.some(p => p.mesh === focusedObject);
                bottomOptionsContainer.classList.toggle('visible', isPlanetFocused);
            
                if (isPlanetFocused) {
                    if (cameraMode === 'inside') {
                        viewToggleButton.textContent = 'Switch to Outside View';
                        followButton.style.display = 'none';
                        followModesContainer.style.display = 'none';
                        viewToggleButton.style.display = 'block';
                    } else if (cameraMode === 'following') {
                        followButton.textContent = 'Stop Following';
                        viewToggleButton.style.display = 'none';
                        followModesContainer.style.display = 'flex';
                        followButton.style.display = 'block';
                    } else { // orbital
                        viewToggleButton.textContent = 'Switch to Inside View';
                        followButton.textContent = 'Follow Planet';
                        followButton.style.display = 'block';
                        viewToggleButton.style.display = 'block';
                        followModesContainer.style.display = 'none';
                    }
                } else {
                    bottomOptionsContainer.classList.remove('visible');
                }
            }

            // Create buttons
            const solarSystemButtonsContainer = document.createElement('div');
            solarSystemButtonsContainer.id = 'solar-system-buttons';
            controlsContainer.appendChild(solarSystemButtonsContainer);
            
            celestialBodies = { 'Galaxy': galaxyParticles };
            const solarSystemBodies = { 'Sun': sun, ...Object.fromEntries(planets.map(p => [p.mesh.name, p.mesh])), 'Asteroid Belt': asteroidBelt.mesh };
            const blackHoleBodies = {
                'Black Hole 1': createBlackHole('Black Hole 1', new THREE.Vector3(5000000, 50000, -2000000)),
                'Black Hole 2': createBlackHole('Black Hole 2', new THREE.Vector3(-4000000, -20000, 3000000)),
                'Black Hole 3': createBlackHole('Black Hole 3', new THREE.Vector3(1000000, 80000, 6000000)),
                'Black Hole 4': createBlackHole('Black Hole 4', new THREE.Vector3(-6000000, 0, -5000000)),
                'Black Hole 5': createBlackHole('Black Hole 5', new THREE.Vector3(7000000, -40000, 1000000)),
            };
            Object.assign(celestialBodies, solarSystemBodies, blackHoleBodies);
            
            const createButton = (name, object, container, isSolarSystemMember) => {
                const button = document.createElement('button');
                button.textContent = name;
                button.className = 'planet-button';
                button.addEventListener('click', () => {
                    if (!isSolarSystemMember) {
                        solarSystemButtonsContainer.style.display = 'none';
                    }

                    const isPlanet = planets.some(p => p.mesh === object);
                    currentPlanetIndex = isPlanet ? planets.findIndex(p => p.mesh === object) : null;
                    cameraMode = 'orbital';
                    
                    let newDistance;
                    if (object.geometry && object.geometry.parameters && object.geometry.parameters.radius) {
                        const radius = object.geometry.parameters.radius;
                        const distanceMultiplier = name.includes('Black Hole') ? 25 : 5; // Zoom closer to planets
                        newDistance = radius * distanceMultiplier;
                    } else {
                        newDistance = name === 'Galaxy' ? 15000000 : 15000;
                    }

                    startTransition(object, newDistance);
                    updateButtons(button);
                    updateSelectedName(name);
                    updateUiForCameraMode();
                });
                container.appendChild(button);
            };

            createButton('Galaxy', celestialBodies['Galaxy'], controlsContainer, false);

            const solarSystemButton = document.createElement('button');
            solarSystemButton.textContent = 'Solar System';
            solarSystemButton.className = 'planet-button';
            solarSystemButton.addEventListener('click', () => {
                solarSystemButtonsContainer.style.display = 'flex';
                startTransition(solarSystemGroup, 50000);
                updateButtons(solarSystemButton);
                updateSelectedName('Solar System');
                bottomOptionsContainer.classList.remove('visible');
            });
            controlsContainer.appendChild(solarSystemButton);

            Object.entries(solarSystemBodies).forEach(([name, object]) => createButton(name, object, solarSystemButtonsContainer, true));
            Object.entries(blackHoleBodies).forEach(([name, object]) => createButton(name, object, controlsContainer, false));

            updateButtons(document.querySelector('.planet-button'));
            
            viewToggleButton.addEventListener('click', () => {
                cameraMode = cameraMode === 'inside' ? 'orbital' : 'inside';
                if (cameraMode === 'inside') {
                    cameraEuler.set(0, 0, 0, 'YXZ');
                }
                updateUiForCameraMode();
            });
            followButton.addEventListener('click', () => {
                cameraMode = cameraMode === 'following' ? 'orbital' : 'following';
                updateUiForCameraMode();
            });
            document.querySelectorAll('.follow-modes button').forEach(btn => {
                 btn.addEventListener('click', () => {
                    document.querySelectorAll('.follow-modes button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    followingMode = btn.id.replace('-button', '');
                });
            });

            // === Main Animation Loop ===
            const clock = new THREE.Clock();
            const animate = () => {
                requestAnimationFrame(animate);
                const elapsedTime = clock.getElapsedTime();

                if (galaxyParticles) galaxyParticles.rotation.y = animationState.rotationY;
                sun.rotation.y += 0.0005;

                planets.forEach((planet) => {
                    const angle = elapsedTime * (2 * Math.PI / planet.period);
                    planet.mesh.position.set(planet.orbitRadius * Math.sin(angle), 0, planet.orbitRadius * Math.cos(angle));
                    planet.mesh.rotation.y = elapsedTime * (2 * Math.PI / planet.rotationPeriod);
                    if (planet.details.tilt) {
                        planet.mesh.rotation.z = planet.details.tilt;
                    }
                });

                createdMoons.forEach(moon => {
                    if(!moon) return;
                    const parentPosition = moon.parentMesh.position;
                    const angle = elapsedTime * (2 * Math.PI / moon.period);
                    moon.mesh.position.copy(parentPosition).add(new THREE.Vector3(moon.orbitRadius * Math.sin(angle), 0, moon.orbitRadius * Math.cos(angle)));
                    const points = moon.orbitMesh.geometry.attributes.position.array;
                    for (let i = 0; i <= 64; i++) {
                        const theta = (i / 64) * Math.PI * 2;
                        points[i * 3] = parentPosition.x + moon.orbitRadius * Math.cos(theta);
                        points[i * 3 + 1] = parentPosition.y;
                        points[i * 3 + 2] = parentPosition.z + moon.orbitRadius * Math.sin(theta);
                    }
                    moon.orbitMesh.geometry.attributes.position.needsUpdate = true;
                });

                if (asteroidBelt.mesh) asteroidBelt.mesh.rotation.y = elapsedTime * (2 * Math.PI / asteroidBelt.period);

                blackHoles.forEach(bh => { bh.particles.rotation.y += 0.02; });
                
                celestialLabels.forEach(({ label, target }) => {
                    const targetPosition = new THREE.Vector3();
                    target.getWorldPosition(targetPosition);
                    
                    const objectSize = (target.geometry && target.geometry.parameters.radius) ? target.geometry.parameters.radius : 50;
                    label.position.copy(targetPosition);
                    label.position.y += objectSize * 2.5;

                    label.lookAt(camera.position);
                });

                explodingStars.forEach((explosion, index) => {
                    const progress = (Date.now() - explosion.startTime) / 2000;
                    if (progress > 1) {
                        scene.remove(explosion.mesh);
                        explosion.mesh.geometry.dispose();
                        explodingStars.splice(index, 1);
                    } else {
                        const positions = explosion.mesh.geometry.attributes.position.array;
                        for (let i = 0; i < explosion.velocities.length; i++) {
                            positions[i*3] = explosion.velocities[i].x * progress * 50;
                            positions[i*3+1] = explosion.velocities[i].y * progress * 50;
                            positions[i*3+2] = explosion.velocities[i].z * progress * 50;
                        }
                        explosion.mesh.geometry.attributes.position.needsUpdate = true;
                        explosion.mesh.material.opacity = 1.0 - progress;
                    }
                });

                updateCameraPosition();
                renderer.render(scene, camera);
            };

            window.addEventListener('resize', () => {
                 camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        };
    </script>
</body>
</html>